
# coding: utf-8

# # 넘파이 어레이: 인덱싱과 슬라이싱

# ## 주요 내용

# 리스트의 경우처럼 인덱싱과 슬라이싱을 이용하여 어레이 항목들을 확인, 수정할 수 있으며, 새로운 어레이를 생성할 수 있다.
# 여기서는 어레이의 인덱싱과 슬라이싱의 다양한 활용을 배운다.

# ## 1차원 어레이의 인덱싱과 슬라이싱
# 
# 1차원 어레이의 경우 리스트의 인덱싱, 슬라이싱과 동일하게 처리한다. 
# 다만, 슬라이싱의 경우 리턴값 또한 1차원 어레이이다.

# In[1]:

import numpy as np


# ### 인덱싱
# 
# 인덱싱은 숫자 0부터 인덱스가 시작하며, `-1`은 마지막 항목을 의미한다. 

# In[2]:

a = np.arange(10)
a


# In[3]:

a[0], a[2], a[-1]


# ### 슬라이싱
# 
# 두 개의 콜론(':')을 사용하여 슬라이싱 구간의 처음과 끝, 그리고 스텝 
# 옵션을 지정할 수 있다. -1은 역순으로 나열하는 것을 의미한다. 

# In[4]:

a[::-1]


# In[5]:

a[2:9:3] # [시작:끝:계단]


# In[6]:

a[:4]


# In[7]:

a[1:3]


# In[8]:

a[::2]


# In[9]:

a[3:]


# ## 다차원 어레이의 인덱싱과 슬라이싱

# 다차원 어레이에서 사용되는 인덱싱과 슬라이싱은 **해당 어레이의 차원에 맞추어** 작동한다. 
# 즉, 어레이의 차원과 상응하는 튜플 형식으로 인덱싱과 슬라이싱 정보를 사용해야 한다.

# ### 리스트의 인덱싱 되돌아보기
# 
# 먼저 중첩 리스트의 경우 인덱싱을 어떻게 하는지 확인해 보자. 

# In[10]:

b = [[0, 1, 2], [3, 4, 5]]


# 기본적으로 `b`는 길이가 2인 리스트이다. 

# In[11]:

len(b)


# `b`에서 `0`을 뽑아내고자 할 경우 인덱싱을 두 번 연속해서 사용해야 하는데,
# 이는 `0`이 `b`의 첫째 항목의 첫째 항목이기 때문이다. 즉,

# In[12]:

b[0][0]


# `5`의 경우 둘째 항목의 셋째 항목이다.

# In[13]:

b[1][2]


# ### 다차원 어레이 인덱싱

# 반면에 `b`를 이차원 어레이로 다루어 보자.

# In[14]:

b = np.array([[0, 1, 2], [3, 4, 5]])
b


# 2차원 어레이의 경우 인덱스를 행과 열의 개념을 이용하여 아래와 같은 방식으로 사용하면 된다.
# 
# * 0을 추출하고자 할 때: 0행, 0열에 위치한 항목의 의미로 `[0, 0]`을 사용한다.

# In[15]:

b[0, 0]


# * 5의 경우는 1행, 2열에 위치한 항목의 의미로 `[1, 2]`를 사용한다.

# In[16]:

b[1,2]


# **주의:** 인덱스는 0부터 시작한다.

# 보다 다양한 예제들을 이용하여 어레이 인덱싱을 연습해보자.
# 
# 아래 코드에서 정의된 d는 2차원 어레이이며, 대각선에 0, 1, 2를 담고 있다.

# In[17]:

d = np.diag(np.arange(3))
d


# `1`의 위치는 1행, 1열이므로 `[1, 1]`을 이용한다.

# In[18]:

d[1, 1]


# ## 어레이 수정
# 
# 어레이는 가변자료형이다.
# 따라서 리스트의 경우와 마찬가지로 인덱싱을 활용하여 항목을 수정할 수 있다.
# 
# 먼저 리스트에서 인덱싱을 이용하여 항목을 수정하는 것을 확인해보자.

# In[19]:

e = range(3)
e


# 리스트 e의 2번 항목인 3을 5로 변경하려면 아래와 같이 인덱싱을 사용하면 된다.

# In[20]:

e[2] = 5
e


# 동일한 방식으로 어레이의 특정 항목을 변경할 수 있다.

# #### 예제
# 
# 어레이 d의 2행, 1열의 항목값인 0을 10으로 변경하고자 하면 다음과 같이 인덱싱을 이용하면 된다.

# In[21]:

d[2, 1] = 10
d


# **주의:**
# 
# 그렇다면 `d[2]`는 무엇을 의미할까?
# `d`를 리스트라 생각하면 된다. 즉, d의 2번 항목인 `[0, 10, 2]` 어레이를 가리킨다.

# In[22]:

d[2]


# ### 다차원 어레이 슬라이싱
# 
# 다차원 어레이의 슬라이싱은 좀 더 생소하다.
# 복잡하거나 어렵지는 않지만 작동방식에 좀 익숙해져야 한다.

# #### 다차원 어레이 생성
# 
# 먼저, 다음과 같은 모양의 2차원 어레이를 생성해보자. 
# 단, 수동으로 항목들을 입력하면 안된다.
# 
# <table>
#   <tr>
#     <td align=center>0</td>
#     <td align=center>1</td> 
#     <td align=center>2</td>
#     <td align=center>3</td>
#     <td align=center>4</td>
#     <td align=center>5</td>
#   </tr>
#   <tr>
#     <td>10</td>
#     <td>11</td> 
#     <td>12</td>
#     <td>13</td>
#     <td>14</td>
#     <td>15</td>
#   </tr>
#   <tr>
#     <td>20</td>
#     <td>21</td> 
#     <td>22</td>
#     <td>23</td>
#     <td>24</td>
#     <td>25</td>
#   </tr>
#   <tr>
#     <td>30</td>
#     <td>31</td> 
#     <td>32</td>
#     <td>33</td>
#     <td>34</td>
#     <td>35</td>
#   </tr>
#   <tr>
#     <td>40</td>
#     <td>41</td> 
#     <td>42</td>
#     <td>43</td>
#     <td>44</td>
#     <td>45</td>
#   </tr>
#   <tr>
#     <td>50</td>
#     <td>51</td> 
#     <td>52</td>
#     <td>53</td>
#     <td>54</td>
#     <td>55</td>
#   </tr>
# </table>

# * 여러 가지 방법이 있을 수 있으나 shape을 변경하는 방법을 활용하는 것이 가장 기초적이다. 
#     먼저, `np.arange` 함수를 이용하여 길이가 36인 어레이를 생성한 다음에 
#     shape 값을 변경하여 2차원 어레이를 생성한다. 

# In[23]:

a = np.arange(36)
a.shape = (6,6)
a


# In[24]:

a = np.arange(36).reshape((6,6))
a


# 이제 각 행별로 4의 배수를 더하면 원하는 어레이가 얻어지는 성질을 이용한다. 
# 어레이와 숫자의 연산은 각 항목별로 실행된다는 점을 이용한다. 

# In[25]:

a = np.arange(36).reshape((6,6))

for i in range(len(a)):
        for j in range(6):
            a[i, j] = a[i, j] + 4*i
            
a            


# * 어레이의 연산은 항목별로 이루어진다는 점에 착안한다면 아래와 같이 코드를 작성할 수 있다.
# 
#     **주의:** `a[i]`는 `a` 어레이의 `i`번 행을 가리킨다. 예를 들어,
# 
#         a[2] = array([12, 13, 14, 15, 16, 17])
# 
#     이다. 따라서 `a[2] + 4*2`는 `a[2]`의 각각의 항목에 8을 더해주는 식으로 계산된다.
# 
#         a[2] + 4*2 = array([20, 21, 22, 23, 24, 25])

# In[26]:

a = np.arange(36).reshape((6,6))

for i in range(len(a)):
    a[i] = a[i] + 4*i

a


# * 브로드캐스팅이란 고급 기술을 이용하면 훨씬 간단하게 원하는 어레이를 구할 수 있다.
#     브로드캐스팅은 다음 시간에 자세히 다룬다.

# In[27]:

a = np.arange(6) + np.arange(0, 51, 10)[:, np.newaxis]
a


# #### 연습
# 
# 이제 위 어레이를 이용하여 슬라이싱을 연습하도록 해보자. 
# 좀 생소하게 다가올 것이지만, 행과 열의 규칙을 각각 적용하면 된다는 점에 주의하면
# 그렇게 복잡하지는 않을 것이다.
# 
# 먼저 아래 그림에 나와 있는대로 슬라이싱을 따라해보면서 슬라이싱이 어떻게 
# 작동하는지 확인해보자.
# <p>
# <table cellspacing="20">
# <tr>
# <td>
# <img src="../../images/array-slicing.png", width=450>
# </td>
# </tr>
# </table>
# </p>
# 
# 코드의 색깔과 어레이 그림에서 표시된 동일한 색을 가진 상자들 사이의 관계를 주시하면 된다.

# #### 주황색 영역
# 
# * 규칙: 
#     * 행은 0행으로 고정, 즉 인덱스 [0] 사용.
#     * 열은 3열에서 5열 전까지, 즉 슬라이싱 [3:5] 사용.

# In[28]:

a[0, 3:5]


# #### 하늘색 영역
# 
# * 규칙: 
#     * 행은 4행에서 마지막 행까지, 즉 슬라이싱 [4:] 사용.
#     * 열도 4열에서 마지막 열열까지, 즉 슬라이싱 [4:] 사용.

# In[29]:

a[4:, 4:]


# #### 빨강색 영역
# 
# * 규칙: 
#     * 행은 전체 대상, 즉 슬라이싱 [:] 사용.
#     * 열은 2열 고정, 즉 인덱싱 [2] 사용.

# In[30]:

a[:, 2]


# #### 초록색 영역
# 
# * 규칙: 
#     * 행은 2행과 4행 대상, 즉 슬라이싱 [2::2] 사용.
#     * 열은 0열, 2열, 4열 대상, 즉 인덱싱 [::2] 사용.

# In[31]:

a[2::2, ::2]


# ## 마스크(mask) 인덱싱
# 
# `True`, `False`의 불리언 값들로만 이루어진 어레이를 **마스크(mask)**라 부른다. 
# 마스크를 이용하여 인덱싱을 실행할 수 있다.
# 
# **주의:** 마스크 인덱싱은 뷰 방식을 따르지 않는다.

# ##### 예제: 무작위로 생성된 정수들 중에서 3의 배수만 추출하기
# 
# 무작위로 선택된 정수들의 어레이를 생성하기 위해서는 `np.random.randint` 함수를 이용한다. 
# 
# **주의:**
# 무작위성을 높이기 위해 앞서 `np.random.rand`의 경우처럼 `seed` 값을 이용하자.

# In[32]:

np.random.seed(5)


# 이제 0과 20 사이에서 무작위로 15개의 정수를 `3 x 5` 행렬의 모양으로 생성하자.

# In[33]:

a = np.random.randint(0, 20, size=(3, 5))
a


# `a`의 항목들이 3의 배수 여부를 알려주는 어레이는 다음처럼 생성할 수 있다.

# In[34]:

mask = (a % 3 == 0)
mask


# **주의:** 어레이의 연산은 항목별로 실행된다.

# In[35]:

a % 3


# 또한 두 어레이의 모양이 다르면 브로드캐스팅 기능을 이용하여 두 어레이의 모양을 가능하면 통일시킨다.
# 물론, 모양의 통일이 불가능하면 오류가 발생한다.
# 브로드캐스팅에 대해서는 다음 시간에 자세히 배운다.
# 
# 아래 코드에서 `a % 3`은 `3 x 5` 모양의 2차원 어레이 인 반면에 숫자 0은 어레이가 전혀 아니다.
# 하지만 숫자 0으로 이루어진 `3 x 5` 모양의 어레이로 모양을 만들면 두 어레이가 동일한 모양을 갖게 되고,
# 따라서 항목별로 비교가 가능해진다.
# 
# 사실은 `a % 3` 도 이와 같은 방식으로 이해할 수 있다. 
# 즉, 먼저 3으로 이루어진 `3 x 5` 모양의 어레이로 만든 다음에 두 어레이 간의 나머지 연산을 실행한다. 

# In[36]:

a % 3 == 0


# 이제 `a`의 항목들 중에서 `mask`의 항목들 중 `True`가 위치한 곳과 동일한 곳에 위치한 항목들만 뽑아서 1차원 어레이를 만들어 준다.
# 즉, `a`의 항목들 중에서 3의 배수인 숫자들만 뽑아서 어레이로 만들어서 리턴한다.

# In[37]:

multiple_3 = a[mask]
multiple_3


# 다음처럼 보다 간단한 구현이 가능하다.

# In[38]:

a[a % 3 == 0]


# #### 마스크 인덱싱 활용
# 
# 마스크 인덱싱을 이용하여 특정 항목들의 값을 동시에 변경할 수 있다.
# 예를 들어, 생성된 정수들의 어레이어서 3배수값들만을 -1로 변경하고 할 때 마스크 인덱싱 기능을 활용할 수 있다.

# In[39]:

a[a % 3 == 0] = -1
a


# ## 연습문제

# #### 연습
# 
# 슬라이싱을 이용하여 아래 기능을 수행하는 함수 `odd_numbers`와 `even_numbers`를 구현하라.
# 
# * `odd_numbers` 함수는 양의 정수 `n`을 입력 받아 0부터 n까지의 정수 중에서 홀수를 역순으로
#     담은 1차원 어레이를 리턴한다. 
#     
#         In [31]: odd_numbers(10)
#         Out[31]: array([9, 7, 5, 3, 1])
#         
# * `even_numbers` 함수는 양의 정수 `n`을 입력 받아 0부터 n까지의 정수 중에서 짝수를 
#     담은 1차원 어레이를 리턴한다. 
#     
#         In [32]: even_numbers(10)
#         Out[32]: array([0, 2, 4, 6, 8, 10])
#         
# _힌트_: `arange()`, 함수와 슬라이싱을 적절히 활용한다.        

# In[40]:

def odd_numbers(n):
    odds = np.arange(1, n, 2)
    return odds[::-1]

odd_numbers(10)


# In[41]:

def even_numbers(n):
    evens = np.arange(0, n+1, 2)
    return evens

even_numbers(10)

